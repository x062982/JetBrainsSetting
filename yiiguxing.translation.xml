<application>
  <component name="AppStorage">
    <histories>
      <item value="Store" />
      <item value="叫" />
      <item value="A handler for rejected tasks that runs the rejected task * directly in the calling thread of the {@code execute} method, * unless the executor has been shut down, in which case the task * is discarded." />
      <item value="A handler for rejected tasks that discards the oldest unhandled * request and then retries {@code execute}, unless the executor * is shut down, in which case the task is discarded." />
      <item value="A handler for rejected tasks that silently discards the * rejected task." />
      <item value="rejected" />
      <item value="discards" />
      <item value="silently" />
      <item value="access Order" />
      <item value="The iteration ordering method for this linked hash map: {@code true} * for access-order, {@code false} for insertion-order." />
      <item value="Callbacks to allow LinkedHashMap post-actions" />
      <item value="uncontended" />
      <item value="Table initialization and resizing control. When negative, the * table is being initialized or resized: -1 for initialization, * else -(1 + the number of active resizing threads). Otherwise, * when table is null, holds the initial table size to use upon * creation, or 0 for default. After initialization, holds the * next element count value upon which to resize the table." />
      <item value="Spreads (XORs) higher bits of hash to lower and also forces top * bit to 0. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds." />
      <item value="// (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.)" />
      <item value="Dummy value to associate with an Object in the backing Map" />
      <item value="The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds." />
      <item value="MIN TREEIFY CAPACITY" />
      <item value="MAXIMUM CAPACITY" />
      <item value="The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal." />
      <item value="UNTREEIFY THRESHOLD" />
      <item value="Bins are converted to trees when adding an element to a * bin with at least this many nodes." />
      <item value="threshold" />
      <item value="The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage." />
      <item value="除数" />
      <item value="次数" />
      <item value="OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended" />
      <item value="step" />
      <item value="步长" />
      <item value="标准" />
      <item value="增加" />
      <item value="生气" />
      <item value="Augre" />
      <item value="Angre" />
      <item value="Angure" />
      <item value="剩余" />
      <item value="积" />
      <item value="Multi" />
      <item value="For parallel stream pipelines, the action may be called at * whatever time and in whatever thread the element is made available by the * upstream operation. If the action modifies shared state, * it is responsible for providing the required synchronization." />
      <item value="可操作性" />
      <item value="权限" />
      <item value="batch" />
      <item value="parameterized" />
      <item value="外键" />
      <item value="外建" />
      <item value="feign" />
      <item value="feign Id" />
      <item value="material" />
      <item value="材料" />
      <item value="metrical" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="383" />
        <entry key="ENGLISH" value="384" />
        <entry key="ESTONIAN" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="DANISH" value="3" />
        <entry key="FRENCH" value="4" />
        <entry key="KURDISH" value="1" />
        <entry key="LATVIAN" value="1" />
        <entry key="ROMANIAN" value="5" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="JAPANESE" value="1" />
        <entry key="HUNGARIAN" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>